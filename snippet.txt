{
  "accumulate": {
    "prefix": "accumulate",
    "body": [
      "/// 累積和型",
      "///",
      "/// 初期化 O(n)",
      "/// 区間 O(1)",
      "/// 更新は作り直す以外に出来ない",
      "///",
      "/// 逆操作はimos法,",
      "#[derive(PartialEq, Clone, Debug)]",
      "pub struct Accumulate<T>(Vec<T>);",
      "impl<T: Zero + Copy + Add<Output = T> + Sub<Output = T>> Accumulate<T> {",
      "    /// `[0, i)`の総和",
      "    pub fn sum(&self, i: usize) -> T {",
      "        self[i]",
      "    }",
      "    /// 累積和を利用して`[i, j)`間の総和を`O(1)`で求める",
      "    pub fn pertical_sum(&self, i: usize, j: usize) -> T {",
      "        self[j] - self[i]",
      "    }",
      "}",
      "impl<T: Zero + Add<Output = T> + Copy> Index<usize> for Accumulate<T> {",
      "    type Output = T;",
      "    fn index(&self, index: usize) -> &Self::Output {",
      "        &self.0[index]",
      "    }",
      "}",
      "/// 累積和をとります",
      "///",
      "/// `O(n)`",
      "pub fn accumulate<T: Zero + Copy + Add<Output = T> + Sub<Output = T>>(v: &[T]) -> Accumulate<T> {",
      "    let mut res = Vec::with_capacity(v.len() + 1);",
      "    let mut i: T = zero();",
      "    res.push(i);",
      "    for e in v {",
      "        i = i + *e;",
      "        res.push(i);",
      "    }",
      "    Accumulate(res)",
      "}"
    ]
  },
  "bfs": {
    "prefix": "bfs",
    "body": [
      "/// 重みなしグラフにおいて、幅優先探索を用いて任意の頂点から、各頂点への最短距離を求める",
      "///",
      "/// dist[i] = (startからiまでの最短距離)",
      "pub fn dist_table<'a, G>(g: &'a G, start: G::NodeId) -> Vec<usize>",
      "where",
      "    G: Graph<'a, NodeId = usize>,",
      "{",
      "    let mut dist = vec![std::usize::MAX; g.len()];",
      "    dist[start] = 0;",
      "    for (f, t) in bfs(g, start) {",
      "        dist[t] = dist[f] + 1;",
      "    }",
      "    dist",
      "}",
      "/// 重みなしグラフでの2頂点の最短距離を幅優先探索で求める",
      "///",
      "/// goalまでの経路が見つかった時点で探索を打ち切るので、",
      "/// グラフのサイズの大きさに直接の影響を受けないことが期待される",
      "pub fn shortest_path<'a, G: Graph<'a, NodeId = usize>>(",
      "    g: &'a G,",
      "    start: usize,",
      "    goal: usize,",
      ") -> usize {",
      "    let mut dist = vec![std::usize::MAX; g.len()];",
      "    dist[start] = 0;",
      "    for (f, t) in bfs(g, start) {",
      "        if t == goal {",
      "            return dist[f] + 1;",
      "        }",
      "        dist[t] = dist[f] + 1;",
      "    }",
      "    std::usize::MAX",
      "}",
      "pub struct Bfs<'a, G: Graph<'a>> {",
      "    visited: Vec<bool>,",
      "    q: VecDeque<(G::NodeId, Option<G::NodeId>)>,",
      "    g: &'a G,",
      "}",
      "impl<'a, G: Graph<'a>> Iterator for Bfs<'a, G> {",
      "    type Item = (G::NodeId, G::NodeId);",
      "    fn next(&mut self) -> Option<Self::Item> {",
      "        if let Some((u, prev)) = self.q.pop_front() {",
      "            for v in self.g.neighbors(u) {",
      "                if !self.visited[self.g.index(v)] {",
      "                    self.visited[self.g.index(v)] = true;",
      "                    self.q.push_back((v, Some(u)));",
      "                }",
      "            }",
      "            if let Some(prev) = prev {",
      "                Some((prev, u))",
      "            } else {",
      "                self.next()",
      "            }",
      "        } else {",
      "            None",
      "        }",
      "    }",
      "}",
      "/// `start`の頂点からの幅優先探索時の、",
      "/// 頂点から頂点の接続をイテレートするIteratorを作る",
      "///",
      "/// ```rust",
      "/// use sfcpl::graph::{util::make_undirected_graph, bfs::bfs};",
      "///",
      "/// let e = &[(0, 2), (0, 1), (1, 2), (2, 3), (3, 4), (3, 5), (1, 5)];",
      "///",
      "/// let g = make_undirected_graph(6, e);",
      "///",
      "/// for (f, t) in bfs(&g, 0) {",
      "///     println!(\"{} -> {}\", f, t);",
      "/// }",
      "/// ```",
      "///",
      "/// これは",
      "///",
      "/// `0 -> 2`",
      "///",
      "/// `0 -> 1`",
      "///",
      "/// `2 -> 3`",
      "///",
      "/// `1 -> 5`",
      "///",
      "/// `3 -> 4`",
      "///",
      "/// を表示する",
      "pub fn bfs<'a, G>(g: &'a G, start: G::NodeId) -> Bfs<'a, G>",
      "where",
      "    G: Graph<'a, NodeId = usize>,",
      "{",
      "    let n = g.len();",
      "    let mut visited = vec![false; n];",
      "    let mut q = VecDeque::new();",
      "    visited[start] = true;",
      "    q.push_back((start, None));",
      "    Bfs { visited, q, g }",
      "}"
    ]
  },
  "binary_powering": {
    "prefix": "binary_powering",
    "body": [
      "/// 二分累乗法",
      "/// `O(log n)`で累乗を求める",
      "///",
      "/// modを取らないときはmに0を指定",
      "pub fn binary_powering(n: usize, r: usize, m: usize) -> usize {",
      "    let mut a = n;",
      "    let mut n = r;",
      "    let mut res = 1usize;",
      "    let m = if m != 0 { Some(m) } else { None };",
      "    while n > 0 {",
      "        if n & 1 != 0 {",
      "            res *= a;",
      "            if let Some(m) = m {",
      "                res %= m",
      "            }",
      "        }",
      "        a *= a;",
      "        if let Some(m) = m {",
      "            a %= m;",
      "        }",
      "        n >>= 1;",
      "    }",
      "    res",
      "}"
    ]
  },
  "binary_search": {
    "prefix": "binary_search",
    "body": [
      "/// # Usage",
      "///",
      "/// `T`は基本的にusizeが入る想定",
      "///",
      "/// `pred`について`l`側が`true`、",
      "/// `r`側が`false`を返すような単調性を持っているとき、",
      "///",
      "/// `pred`を満たす`T`の中で最も大きいものを求める。",
      "///",
      "/// 最初に`l`と`r`について`pred`がそれぞれ`true`、`false`を返すかどうかを調べるので、",
      "/// 範囲は閉空間で指定して良い。",
      "///",
      "/// 返り値`res`は必ず、",
      "///",
      "/// Some(inner) (l <= inner <= r) | None",
      "///",
      "/// になる",
      "///",
      "/// ```rust",
      "/// use sfcpl::binary_search::binary_search;",
      "///",
      "/// let v = vec![1, 3, 3, 3, 4, 6, 7, 7, 8, 10];",
      "/// assert_eq!(3, binary_search(|i| v[i] < 4, 0, v.len() - 1).unwrap());",
      "/// assert_eq!(9, binary_search(|i| v[i] <= 10, 0, v.len() - 1).unwrap());",
      "/// ```",
      "pub fn binary_search<T, F>(pred: F, l: T, r: T) -> Option<T>",
      "where",
      "    T: Add<Output = T> + Div<Output = T> + PartialEq + Copy + From<u8>,",
      "    F: Fn(T) -> bool,",
      "{",
      "    if !pred(l) {",
      "        return None;",
      "    }",
      "    if pred(r) {",
      "        return Some(r);",
      "    }",
      "    let mut l = l;",
      "    let mut r = r;",
      "    let two = T::from(2);",
      "    loop {",
      "        let m = (l + r) / two;",
      "        if l == m {",
      "            break Some(l);",
      "        }",
      "        if pred(m) {",
      "            l = m;",
      "        } else {",
      "            r = m;",
      "        }",
      "    }",
      "}",
      "/// `v`以上の要素が最初に現れるindex",
      "///",
      "/// ```rust",
      "/// use sfcpl::binary_search::lower_bound;",
      "///",
      "/// let v: &[i32] = &[1, 3, 3, 4, 5];",
      "/// assert_eq!(lower_bound(v, &0), 0);",
      "/// assert_eq!(lower_bound(v, &1), 0);",
      "/// assert_eq!(lower_bound(v, &2), 1);",
      "/// assert_eq!(lower_bound(v, &3), 1);",
      "/// assert_eq!(lower_bound(v, &4), 3);",
      "/// assert_eq!(lower_bound(v, &5), 4);",
      "/// assert_eq!(lower_bound(v, &999), 5);",
      "/// ```",
      "pub fn lower_bound<T: PartialOrd>(v: &[T], val: &T) -> usize {",
      "    let t = binary_search(|x| v[x] < *val, 0, v.len() - 1);",
      "    match t {",
      "        Some(e) => e + 1,",
      "        None => 0,",
      "    }",
      "}",
      "/// `v`より大きい要素が最初に現れるindex",
      "///",
      "/// ```rust",
      "/// use sfcpl::binary_search::upper_bound;",
      "///",
      "/// let v: &[i32] = &[1, 3, 3, 4, 5];",
      "/// assert_eq!(upper_bound(v, &0), 0);",
      "/// assert_eq!(upper_bound(v, &1), 1);",
      "/// assert_eq!(upper_bound(v, &2), 1);",
      "/// assert_eq!(upper_bound(v, &3), 3);",
      "/// assert_eq!(upper_bound(v, &4), 4);",
      "/// assert_eq!(upper_bound(v, &5), 5);",
      "/// assert_eq!(upper_bound(v, &999), 5);",
      "/// ```",
      "pub fn upper_bound<T: PartialOrd>(v: &[T], val: &T) -> usize {",
      "    let t = binary_search(|x| v[x] <= *val, 0, v.len() - 1);",
      "    match t {",
      "        Some(e) => e + 1,",
      "        None => 0,",
      "    }",
      "}"
    ]
  },
  "binomial_coefficient": {
    "prefix": "binomial_coefficient",
    "body": [
      "pub trait PartialBinomialCoefficient {",
      "    fn partial_binomial(&self, n: usize, k: usize) -> Option<ModInt>;",
      "}",
      "pub trait BinomialCoefficient: PartialBinomialCoefficient {",
      "    /// `n C k`",
      "    fn binomial(&self, n: usize, k: usize) -> ModInt {",
      "        self.partial_binomial(n, k).unwrap()",
      "    }",
      "}",
      "/// Binomial Coefficient Table with DP",
      "/// 二項係数を`O(1)`で計算するためのテーブル",
      "///",
      "/// factrial = [1, 1, 2, 6, 24, 120, ...],",
      "///",
      "/// `1 <= k <= n <= 10^7` 程度",
      "pub struct BCTDP {",
      "    _modulo: NonZeroU32,",
      "    factorial: Vec<ModInt>,",
      "    inverse: Vec<ModInt>,",
      "    factorial_inverse: Vec<ModInt>,",
      "}",
      "impl BCTDP {",
      "    /// 初期化",
      "    ///",
      "    /// DPを用いて `O(n log m)`",
      "    /// 割り算を用いるので `log m` がつく",
      "    ///",
      "    /// `1 <= k <= n <= 10^7` 程度",
      "    pub fn new(n: usize, modulo: usize) -> BCTDP {",
      "        let mut factorial = vec![ModInt::new(1, modulo), ModInt::new(1, modulo)];",
      "        factorial.reserve_exact(n);",
      "        let mut inverse = vec![ModInt::new(0, modulo), ModInt::new(1, modulo)];",
      "        inverse.reserve_exact(n);",
      "        let mut factorial_inverse = vec![ModInt::new(1, modulo), ModInt::new(1, modulo)];",
      "        factorial_inverse.reserve_exact(n);",
      "        for i in 2..=n {",
      "            factorial.push(factorial[i - 1] * i);",
      "            inverse.push(modulo.to_mint(modulo) - inverse[modulo % i] * (modulo / i));",
      "            factorial_inverse.push(factorial_inverse[i - 1] * inverse[i]);",
      "        }",
      "        Self {",
      "            _modulo: NonZeroU32::new(modulo as u32).unwrap(),",
      "            factorial,",
      "            inverse,",
      "            factorial_inverse,",
      "        }",
      "    }",
      "    pub fn get_mod(&self) -> usize {",
      "        self._modulo.get() as usize",
      "    }",
      "    pub fn factorial(&self, n: usize) -> ModInt {",
      "        self.factorial[n]",
      "    }",
      "    pub fn factorial_inverse(&self, n: usize) -> ModInt {",
      "        self.factorial_inverse[n]",
      "    }",
      "    /// `n` の mod self._modulo における逆元",
      "    pub fn inv(&self, n: usize) -> ModInt {",
      "        self.inverse[n]",
      "    }",
      "}",
      "impl PartialBinomialCoefficient for BCTDP {",
      "    fn partial_binomial(&self, n: usize, k: usize) -> Option<ModInt> {",
      "        Some(if n < k {",
      "            ModInt::zero()",
      "        } else {",
      "            self.factorial[n] * self.factorial_inverse[k] * self.factorial_inverse[n - k]",
      "        })",
      "    }",
      "}",
      "impl BinomialCoefficient for BCTDP {}",
      "/// `n` が固定値のときに有効",
      "/// `(n(固定値), mod, _[i] = n C i)`",
      "///",
      "/// 初期化: `O(n)`",
      "///",
      "/// `1 <= n <= 10^9 && 1 <= k <= 10^7` 程度",
      "pub struct BCTholdN(usize, NonZeroU32, Vec<ModInt>);",
      "impl BCTholdN {",
      "    pub fn new(mut n: usize, m: usize) -> Self {",
      "        let size = n;",
      "        let mut c = vec![ModInt::new(1, m), ModInt::new(n, m)];",
      "        c.reserve_exact(n + 1);",
      "        for i in 2..=n {",
      "            n -= 1;",
      "            let prev = *c.last().unwrap();",
      "            c.push(prev * n / i);",
      "        }",
      "        Self(size, NonZeroU32::new(m as u32).unwrap(), c)",
      "    }",
      "}",
      "impl PartialBinomialCoefficient for BCTholdN {",
      "    /// #Panic",
      "    ///",
      "    /// self.0 == _n でないとき",
      "    fn partial_binomial(&self, _n: usize, k: usize) -> Option<ModInt> {",
      "        if _n != self.0 {",
      "            None",
      "        } else {",
      "            Some(self.2[k])",
      "        }",
      "    }",
      "}",
      "/// `n, k` の2変数についての `n C k` の表を作る",
      "///",
      "/// `1 <= k <= n <= 2000` 程度",
      "pub struct BCTSmallNK {",
      "    n: usize,",
      "    _modulo: NonZeroU32,",
      "    dp: Vec<Vec<ModInt>>,",
      "}",
      "impl BCTSmallNK {",
      "    pub fn new(n: usize, modulo: usize) -> Self {",
      "        let mut dp = vec![vec![ModInt::new(0, modulo); n + 1]; n + 1];",
      "        dp[0][0] = 1.to_mint(modulo);",
      "        for i in 1..n {",
      "            dp[i][0] = 1.to_mint(modulo);",
      "            for j in 1..n {",
      "                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];",
      "            }",
      "        }",
      "        Self {",
      "            n,",
      "            _modulo: NonZeroU32::new(modulo as u32).unwrap(),",
      "            dp,",
      "        }",
      "    }",
      "    pub fn size(&self) -> usize {",
      "        self.n",
      "    }",
      "    pub fn get_mod(&self) -> usize {",
      "        self._modulo.get() as usize",
      "    }",
      "}",
      "impl PartialBinomialCoefficient for BCTSmallNK {",
      "    fn partial_binomial(&self, n: usize, k: usize) -> Option<ModInt> {",
      "        if n > self.size() || k > self.size() {",
      "            panic!(\"n or k is too large, compere to dp table!\")",
      "        }",
      "        Some(self.dp[n][k])",
      "    }",
      "}",
      "impl BinomialCoefficient for BCTSmallNK {}"
    ]
  },
  "bitset": {
    "prefix": "bitset",
    "body": [
      "pub type BitSet = Vec<bool>;",
      "/// bitの数を持つ",
      "#[derive(Debug, Copy, Clone)]",
      "pub struct BitSetsGen {",
      "    size: usize,",
      "}",
      "impl BitSetsGen {",
      "    /// サイズを指定してコンストラクト",
      "    pub fn new(n: usize) -> Self {",
      "        Self { size: n }",
      "    }",
      "    /// サイズを返す",
      "    pub fn len(&self) -> usize {",
      "        self.size",
      "    }",
      "    /// 合計で生成される組み合わせの数、`(2 ^ size)`",
      "    pub fn combinations(&self) -> usize {",
      "        1 << self.size",
      "    }",
      "}",
      "impl IntoIterator for BitSetsGen {",
      "    type Item = BitSet;",
      "    type IntoIter = IntoIterBitSet;",
      "    fn into_iter(self) -> Self::IntoIter {",
      "        IntoIterBitSet {",
      "            size: self.len(),",
      "            current: 0,",
      "        }",
      "    }",
      "}",
      "/// BitSetの所有権を奪ったIterator",
      "///",
      "///(実際にはコピートレイトにより`into_iter()`後もBitSetは有効である)",
      "///",
      "/// 保持するのはサイズと次に生成する数字だけ",
      "///",
      "/// Iteratorは長さ`2 ^ size`で、",
      "/// はじめは`[false, false, ..., false, false]`から始まり、",
      "///",
      "/// `[false, false, ..., false, true]`",
      "///",
      "/// `[false, false, ..., true, false]`",
      "///",
      "/// `[false, false, ..., true, true]`のように右詰で続く。",
      "///",
      "/// 最後は`[true, true, ..., true, true]`である。",
      "#[derive(Copy, Clone, Debug)]",
      "pub struct IntoIterBitSet {",
      "    size: usize,",
      "    current: usize,",
      "}",
      "impl Iterator for IntoIterBitSet {",
      "    type Item = BitSet;",
      "    fn next(&mut self) -> Option<Self::Item> {",
      "        if self.current == (1 << self.size) {",
      "            None",
      "        } else {",
      "            let res = Some(",
      "                (0..self.size)",
      "                    .rev()",
      "                    .map(|x| self.current & (1 << x) != 0)",
      "                    .collect::<Vec<_>>(),",
      "            );",
      "            self.current += 1;",
      "            res",
      "        }",
      "    }",
      "}",
      "pub trait BitsOps {",
      "    fn new(n: usize) -> Self;",
      "    fn count_zeros(&self) -> usize;",
      "    fn count_ones(&self) -> usize;",
      "    fn grow(&mut self, bits: usize);",
      "    fn put(&mut self, bits: usize) -> bool;",
      "    fn toggle(&mut self, bit: usize);",
      "    fn set(&mut self, bit: usize, into: bool);",
      "    fn shl(&mut self, rhs: usize);",
      "    fn shr(&mut self, rhs: usize);",
      "    fn format(&self) -> String;",
      "}",
      "impl BitsOps for BitSet {",
      "    fn new(n: usize) -> Self {",
      "        let mut b = 1;",
      "        let mut res = Vec::new();",
      "        while b <= n {",
      "            res.push(b & n != 0);",
      "            b <<= 1;",
      "        }",
      "        res.reverse();",
      "        res",
      "    }",
      "    fn count_zeros(&self) -> usize {",
      "        self.iter().filter(|x| !**x).count()",
      "    }",
      "    fn count_ones(&self) -> usize {",
      "        self.iter().filter(|x| **x).count()",
      "    }",
      "    fn grow(&mut self, bits: usize) {",
      "        self.reverse();",
      "        self.append(&mut vec![false; bits]);",
      "        self.reverse();",
      "    }",
      "    fn put(&mut self, bits: usize) -> bool {",
      "        let prev = self[bits];",
      "        self[bits] = true;",
      "        prev",
      "    }",
      "    fn toggle(&mut self, bit: usize) {",
      "        self[bit] = !self[bit];",
      "    }",
      "    fn set(&mut self, bit: usize, into: bool) {",
      "        self[bit] = into;",
      "    }",
      "    fn shl(&mut self, rhs: usize) {",
      "        self.append(&mut vec![false; rhs]);",
      "    }",
      "    fn shr(&mut self, rhs: usize) {",
      "        let len = self.len();",
      "        let mut res = vec![false; rhs];",
      "        res.append(&mut self[..len - rhs].to_vec());",
      "        *self = res;",
      "    }",
      "    fn format(&self) -> String {",
      "        self.iter().map(|x| if *x { '1' } else { '0' }).collect()",
      "    }",
      "}"
    ]
  },
  "combination": {
    "prefix": "combination",
    "body": [
      "pub fn combination(n: ModInt, k: usize) -> ModInt {",
      "    if k > n.get() as usize {",
      "        panic!(\"n < k, where n in ModInt, k in usize, so cannot calculate n C k\")",
      "    }",
      "    permutation(n, k) / k.factorial()",
      "}",
      "pub fn combination_with_table<T: BinomialCoefficient>(table: &T, n: usize, k: usize) -> ModInt {",
      "    table.binomial(n, k)",
      "}"
    ]
  },
  "dfs": {
    "prefix": "dfs",
    "body": [
      "pub struct Dfs<'a, G: Graph<'a>> {",
      "    visited: Vec<bool>,",
      "    s: Vec<(G::NodeId, Option<G::NodeId>)>,",
      "    g: &'a G,",
      "}",
      "impl<'a, G: Graph<'a>> Iterator for Dfs<'a, G> {",
      "    type Item = (G::NodeId, G::NodeId);",
      "    fn next(&mut self) -> Option<Self::Item> {",
      "        if let Some((u, prev)) = self.s.pop() {",
      "            for v in self.g.neighbors(u) {",
      "                if !self.visited[self.g.index(v)] {",
      "                    self.visited[self.g.index(v)] = true;",
      "                    self.s.push((v, Some(u)));",
      "                }",
      "            }",
      "            if let Some(prev) = prev {",
      "                Some((prev, u))",
      "            } else {",
      "                self.next()",
      "            }",
      "        } else {",
      "            None",
      "        }",
      "    }",
      "}",
      "/// `start`からの深さ優先探索時の、",
      "/// 頂点から頂点の接続をイテレートするIteratorを作る",
      "///",
      "/// ```rust",
      "/// use sfcpl::graph::{util::make_undirected_graph, dfs::dfs};",
      "///",
      "/// let e = &[(0, 2), (0, 1), (1, 2), (2, 3), (3, 4), (3, 5), (1, 5)];",
      "///",
      "/// let g = make_undirected_graph(6, e);",
      "///",
      "/// for (f, t) in dfs(&g, 0) {",
      "///     println!(\"{} -> {}\", f, t);",
      "/// }",
      "/// ```",
      "///",
      "/// これは",
      "///",
      "/// `0 -> 1`",
      "///",
      "/// `1 -> 5`",
      "///",
      "/// `5 -> 3`",
      "///",
      "/// `3 -> 4`",
      "///",
      "/// `0 -> 2`",
      "///",
      "/// を表示する",
      "pub fn dfs<'a, G: Graph<'a, NodeId = usize>>(g: &'a G, start: G::NodeId) -> Dfs<'a, G> {",
      "    let n = g.len();",
      "    let mut visited = vec![false; n];",
      "    let mut s = Vec::new();",
      "    visited[start] = true;",
      "    s.push((start, None));",
      "    Dfs { visited, s, g }",
      "}"
    ]
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "/// 単純グラフじゃないと死ぬ",
      "pub struct Dijkstra {",
      "    g: Vec<Vec<usize>>,",
      "    e: HashMap<(usize, usize), u64>,",
      "}",
      "impl<'a> Graph<'a> for Dijkstra {",
      "    type NodeId = usize;",
      "    type Iter = std::iter::Cloned<std::slice::Iter<'a, Self::NodeId>>;",
      "    fn len(&self) -> usize {",
      "        self.g.len()",
      "    }",
      "    fn is_empty(&self) -> bool {",
      "        self.len() == 0",
      "    }",
      "    fn index(&self, a: Self::NodeId) -> usize {",
      "        a",
      "    }",
      "    fn neighbors(&'a self, a: Self::NodeId) -> Self::Iter {",
      "        self.g[a].iter().cloned()",
      "    }",
      "}",
      "pub fn make_graph_for_dijkstra(n: usize, edges: &[(usize, usize, u64)]) -> Dijkstra {",
      "    let mut g = vec![Vec::new(); n];",
      "    let mut e = HashMap::new();",
      "    for (from, to, weight) in edges.iter() {",
      "        g[*from].push(*to);",
      "        g[*to].push(*from);",
      "        e.insert((*from, *to), *weight);",
      "        e.insert((*to, *from), *weight);",
      "    }",
      "    Dijkstra { g, e }",
      "}",
      "impl<'a> Dijkstra {",
      "    pub fn weight(&self, from: usize, to: usize) -> u64 {",
      "        self.e[&(from, to)]",
      "    }",
      "    pub fn add_edge(&mut self, edge: (usize, usize, u64)) {",
      "        self.g[edge.0].push(edge.1);",
      "        self.g[edge.1].push(edge.0);",
      "        self.e.insert((edge.0, edge.1), edge.2);",
      "        self.e.insert((edge.1, edge.0), edge.2);",
      "    }",
      "}",
      "/// 任意の頂点から全ての頂点までの最短経路を求める",
      "///",
      "/// `O((V + E) log V)`",
      "pub fn dijkstra<'a>(g: &'a Dijkstra, start: usize) -> Vec<u64> {",
      "    let mut d = Vec::with_capacity(g.len());",
      "    let mut q: BinaryHeap<Reverse<(u64, usize)>> = BinaryHeap::with_capacity(g.len());",
      "    for i in 0..g.len() {",
      "        let j = if i == start { 0 } else { std::u64::MAX };",
      "        d.push(j);",
      "        q.push(Reverse((j, i)));",
      "    }",
      "    while !q.is_empty() {",
      "        let u = q.pop().unwrap().0;",
      "        for v in g.neighbors(u.1) {",
      "            let w = g.weight(u.1, v);",
      "            if d[v] > d[u.1] + w {",
      "                d[v] = d[u.1] + w;",
      "                q.push(Reverse((w, v)));",
      "            }",
      "        }",
      "    }",
      "    d",
      "}",
      "/// 二点間の最短距離とその経路を求める",
      "pub fn dijkstra_with_path<'a>(g: &'a Dijkstra, start: usize, goal: usize) -> (Vec<usize>, u64) {",
      "    let mut d = Vec::with_capacity(g.len());",
      "    let mut q: BinaryHeap<Reverse<(u64, usize)>> = BinaryHeap::with_capacity(g.len());",
      "    for i in 0..g.len() {",
      "        let j = if i == start { 0 } else { std::u64::MAX };",
      "        d.push(j);",
      "        q.push(Reverse((j, i)));",
      "    }",
      "    let mut p: Vec<Option<usize>> = vec![None; g.len()];",
      "    while !q.is_empty() {",
      "        let u = q.pop().unwrap().0;",
      "        for v in g.neighbors(u.1) {",
      "            let w = g.weight(u.1, v);",
      "            if d[v] > d[u.1] + w {",
      "                d[v] = d[u.1] + w;",
      "                p[v] = Some(u.1);",
      "                q.push(Reverse((w, v)));",
      "            }",
      "        }",
      "    }",
      "    let mut path = vec![goal];",
      "    loop {",
      "        match p[*path.last().unwrap()] {",
      "            Some(prev) if prev == start => {",
      "                path.push(prev);",
      "                break;",
      "            }",
      "            Some(prev) => {",
      "                path.push(prev);",
      "            }",
      "            None => break,",
      "        }",
      "    }",
      "    path.reverse();",
      "    (path, d[goal])",
      "}"
    ]
  },
  "factorial": {
    "prefix": "factorial",
    "body": [
      "pub trait Factoriable: Sized + NumOps + NumAssignOps + Copy + TryInto<usize> {",
      "    fn falling(self, take: usize) -> Self;",
      "    fn rising(self, take: usize) -> Self;",
      "    fn factorial(self) -> Self {",
      "        self.falling(self.try_into().ok().unwrap())",
      "    }",
      "}",
      "macro_rules ! impl_factorialbe {(\\$ (\\$ t : ty ) ,* ) => {\\$ (impl Factoriable for \\$ t {fn falling (self , take : usize ) -> Self {let mut res = Self :: one () ; let mut c = self ; for _ in 0 .. take {res *= c ; c -= Self :: one () ; } res } fn rising (self , take : usize ) -> Self {let mut res = Self :: one () ; let mut c = self ; for _ in 0 .. take {res *= c ; c += 1 ; } res } } ) * } ; }",
      "impl_factorialbe!(usize, u8, u16, u32, u64, isize, i8, i16, i32, i64, ModInt);"
    ]
  },
  "fenwick_tree": {
    "prefix": "fenwick_tree",
    "body": [
      "/// 更新、区間和の取得がともに`O(log n)`で",
      "/// 可能なデータ構造",
      "#[derive(Debug, Clone)]",
      "pub struct FenwickTree<T: Add> {",
      "    len: usize,",
      "    segment: Vec<T>,",
      "}",
      "impl<T: Add + Sub<Output = T> + Zero + Clone + Ord + Into<usize>> FenwickTree<T> {",
      "    /// サイズを指定して、zerosで初期化",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            len: n,",
      "            segment: vec![T::zero(); n + 1],",
      "        }",
      "    }",
      "    /// 配列から構築",
      "    pub fn from(vec: &[T]) -> Self {",
      "        let m = vec.iter().max().unwrap().clone();",
      "        let mut f = Self::new(m.into());",
      "        for (i, v) in vec.iter().enumerate() {",
      "            f.add(i, v.clone());",
      "        }",
      "        f",
      "    }",
      "    /// 扱える要素の最大値",
      "    pub fn len(&self) -> usize {",
      "        self.len",
      "    }",
      "    /// # 更新",
      "    /// `i`番目の要素 += `v`",
      "    ///",
      "    /// `O(log n)`",
      "    pub fn add(&mut self, i: usize, v: T) {",
      "        let mut i = i + 1;",
      "        while i <= self.len() {",
      "            self.segment[i] = self.segment[i].clone() + v.clone();",
      "            i += (i as i64 & -(i as i64)) as usize;",
      "        }",
      "    }",
      "    /// `[0..i)`の区間和",
      "    ///",
      "    /// `O(log n)`",
      "    pub fn sum(&self, mut i: usize) -> T {",
      "        let mut s = T::zero();",
      "        while i > 0 {",
      "            s = s.clone() + self.segment[i].clone();",
      "            i -= (i as i64 & -(i as i64)) as usize;",
      "        }",
      "        s",
      "    }",
      "    /// `[a..b)`の区間和",
      "    ///",
      "    /// `O(log n)`",
      "    pub fn partial_sum(&self, a: usize, b: usize) -> T {",
      "        self.sum(b) - self.sum(a)",
      "    }",
      "}"
    ]
  },
  "graph": {
    "prefix": "graph",
    "body": [
      "pub trait Graph<'a> {",
      "    type NodeId: Copy;",
      "    type Iter: Iterator<Item = Self::NodeId>;",
      "    fn len(&self) -> usize;",
      "    fn is_empty(&self) -> bool;",
      "    fn index(&self, i: Self::NodeId) -> usize;",
      "    fn neighbors(&'a self, i: Self::NodeId) -> Self::Iter;",
      "}",
      "/// 重みなしグラフ",
      "pub type UnweightedGraph = Vec<Vec<usize>>;",
      "impl<'a> Graph<'a> for UnweightedGraph {",
      "    type NodeId = usize;",
      "    type Iter = std::iter::Cloned<std::slice::Iter<'a, Self::NodeId>>;",
      "    fn len(&self) -> usize {",
      "        self.len()",
      "    }",
      "    fn is_empty(&self) -> bool {",
      "        self.len() == 0",
      "    }",
      "    fn index(&self, a: Self::NodeId) -> usize {",
      "        a",
      "    }",
      "    fn neighbors(&'a self, a: Self::NodeId) -> Self::Iter {",
      "        self[a].iter().cloned()",
      "    }",
      "}",
      "/// 重みありグラフ",
      "pub type WeightedNodeGraph<W> = Vec<Vec<(usize, W)>>;",
      "impl<'a, W> Graph<'a> for WeightedNodeGraph<W>",
      "where",
      "    W: std::marker::Copy + Clone + 'a,",
      "{",
      "    type NodeId = (usize, W);",
      "    type Iter = std::iter::Cloned<std::slice::Iter<'a, Self::NodeId>>;",
      "    fn len(&self) -> usize {",
      "        self.len()",
      "    }",
      "    fn is_empty(&self) -> bool {",
      "        self.len() == 0",
      "    }",
      "    fn index(&self, a: Self::NodeId) -> usize {",
      "        a.0",
      "    }",
      "    fn neighbors(&'a self, a: Self::NodeId) -> Self::Iter {",
      "        self[a.0].iter().cloned()",
      "    }",
      "}",
      "/// 重みなし有向グラフ",
      "pub fn make_directed_graph(n: usize, edges: &[(usize, usize)]) -> UnweightedGraph {",
      "    let mut g = vec![vec![]; n];",
      "    for &(u, v) in edges.iter() {",
      "        g[u].push(v);",
      "    }",
      "    g",
      "}",
      "/// 重みなし無向グラフ",
      "pub fn make_undirected_graph(n: usize, edges: &[(usize, usize)]) -> UnweightedGraph {",
      "    let mut g = vec![vec![]; n];",
      "    for &(u, v) in edges.iter() {",
      "        g[u].push(v);",
      "        g[v].push(u);",
      "    }",
      "    g",
      "}",
      "/// 重み付き有向グラフ",
      "pub fn make_weighted_directed_graph<W: Clone>(",
      "    n: usize,",
      "    edges: &[(usize, usize, W)],",
      ") -> WeightedNodeGraph<W> {",
      "    let mut g = vec![vec![]; n];",
      "    for &(u, v, ref w) in edges.iter() {",
      "        g[u].push((v, w.clone()));",
      "    }",
      "    g",
      "}",
      "/// 重み付き無向グラフ",
      "pub fn make_weighted_undirected_graph<W: Clone>(",
      "    n: usize,",
      "    edges: &[(usize, usize, W)],",
      ") -> WeightedNodeGraph<W> {",
      "    let mut g = vec![vec![]; n];",
      "    for &(u, v, ref w) in edges.iter() {",
      "        g[u].push((v, w.clone()));",
      "        g[v].push((u, w.clone()));",
      "    }",
      "    g",
      "}"
    ]
  },
  "inversation": {
    "prefix": "inversation",
    "body": [
      "/// 配列の転倒数をFenwickTree<Sum>を利用してカウント",
      "///",
      "/// `O(n log n)`",
      "///",
      "/// #[test]",
      "/// fn inversation_test() {",
      "///     let v = vec![3, 1, 2];",
      "///     assert_eq!(inversation(&v), 2);",
      "///     let v = vec![3, 2, 1];",
      "///     assert_eq!(inversation(&v), 3);",
      "///     let v = vec![3, 3, 3];",
      "///     assert_eq!(inversation(&v), 0);",
      "///     let v = vec![1, 2, 4, 3, 6, 5];",
      "///     assert_eq!(inversation(&v), 2);",
      "/// }",
      "pub fn inversation(v: &Vec<usize>) -> usize {",
      "    let m = *v.iter().max().unwrap();",
      "    let mut f = FenwickTree::new(m + 1);",
      "    let mut t = 0usize;",
      "    for i in 0..v.len() {",
      "        t += i - f.sum(v[i] + 1);",
      "        f.add(v[i], 1);",
      "    }",
      "    t",
      "}"
    ]
  },
  "minmax": {
    "prefix": "minmax",
    "body": [
      "#[macro_export]",
      "macro_rules ! minimum {(\\$ (\\$ e : expr ) ,+ ) => {{let mut res = None ; \\$ (match res {Some (v ) => res = Some (std :: cmp :: min (v , \\$ e ) ) , None => res = Some (\\$ e ) , } ) + res . unwrap () } } ; }",
      "#[macro_export]",
      "macro_rules ! maximum {(\\$ (\\$ e : expr ) ,+ ) => {{let mut res = None ; \\$ (match res {Some (v ) => res = Some (std :: cmp :: max (v , \\$ e ) ) , None => res = Some (\\$ e ) , } ) + res . unwrap () } } ; }"
    ]
  },
  "modint": {
    "prefix": "modint",
    "body": [
      "/// n % m",
      "/// ただし答えが負になる場合は余分にmを足すことで一意な値を保証",
      "///",
      "/// # Panic",
      "/// 異なるmod間での演算をattemptした時",
      "fn compensated_rem(n: i64, m: usize) -> i64 {",
      "    match n % m as i64 {",
      "        r if r >= 0 => r,",
      "        r => r + m as i64,",
      "    }",
      "}",
      "#[derive(Debug, Copy, Clone, Eq, PartialEq)]",
      "pub enum Modulo {",
      "    Static(NonZeroU32),",
      "    Dynamic,",
      "}",
      "impl Modulo {",
      "    pub fn get(&self) -> Option<u32> {",
      "        match self {",
      "            Modulo::Static(nz) => Some(nz.get()),",
      "            Modulo::Dynamic => None,",
      "        }",
      "    }",
      "}",
      "/// `ModInt -> PrimiteveInt` への暗黙のキャストは行わない!",
      "/// (get関数を提供するのでそれ使ってどうぞ)",
      "///",
      "/// `PrimitiveInt -> ModInt` は許可する",
      "#[derive(Debug, Clone, Copy)]",
      "pub struct ModInt {",
      "    num: i64,",
      "    _modulo: Modulo,",
      "}",
      "impl Into<usize> for ModInt {",
      "    fn into(self) -> usize {",
      "        self.get() as usize",
      "    }",
      "}",
      "pub trait IntoModInt: Copy {",
      "    fn to_mint<M: TryInto<u32> + Copy>(self, modulo: M) -> ModInt;",
      "}",
      "macro_rules ! impl_into_mint {(\\$ (\\$ t : ty ) ,* ) => {\\$ (impl IntoModInt for \\$ t {fn to_mint < M : TryInto < u32 > + Copy > (self , modulo : M ) -> ModInt {ModInt :: new (self , modulo ) } } ) * } ; }",
      "impl_into_mint!(usize, u8, u16, u32, u64, isize, i8, i16, i32, i64);",
      "impl PartialEq for ModInt {",
      "    fn eq(&self, other: &Self) -> bool {",
      "        if !check_mod_eq(self, other).1 {",
      "            panic!(\"cannot compare these values because they have different modulo number\")",
      "        }",
      "        self.get() == other.num",
      "    }",
      "}",
      "impl PartialOrd for ModInt {",
      "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {",
      "        if !check_mod_eq(self, other).1 {",
      "            None",
      "        } else {",
      "            Some(self.get().cmp(&other.num))",
      "        }",
      "    }",
      "}",
      "fn check_mod_eq(a: &ModInt, b: &ModInt) -> (NonZeroU32, bool) {",
      "    match (a._modulo, b._modulo) {",
      "        (Modulo::Static(a), Modulo::Static(b)) => {",
      "            if a == b {",
      "                (a, true)",
      "            } else {",
      "                (unsafe { NonZeroU32::new_unchecked(1) }, false)",
      "            }",
      "        }",
      "        (Modulo::Static(m), Modulo::Dynamic) | (Modulo::Dynamic, Modulo::Static(m)) => (m, true),",
      "        (Modulo::Dynamic, Modulo::Dynamic) => (unsafe { NonZeroU32::new_unchecked(1) }, false),",
      "    }",
      "}",
      "impl ModInt {",
      "    /// always `_modulo > num >= 0 && _modulo >= 1`",
      "    pub fn new<N: TryInto<i64>, M: TryInto<u32> + Copy>(n: N, m: M) -> Self {",
      "        let m = NonZeroU32::new(m.try_into().ok().expect(\"modulo number may be wrong\")).unwrap();",
      "        let r = n",
      "            .try_into()",
      "            .ok()",
      "            .expect(\"modulo number maybe over i64 range\");",
      "        let num = compensated_rem(r, m.get() as usize);",
      "        Self {",
      "            num,",
      "            _modulo: Modulo::Static(m),",
      "        }",
      "    }",
      "    /// get inner value",
      "    pub fn get(&self) -> i64 {",
      "        self.num",
      "    }",
      "    /// mod of modint",
      "    ///",
      "    /// # Panic",
      "    /// if variant is Modulo::Dynamic",
      "    pub fn get_mod(&self) -> usize {",
      "        self._modulo.get().unwrap() as usize",
      "    }",
      "    /// return the power of self with mod, using binary powering method",
      "    /// cannot use of Dynamic type mod Self",
      "    pub fn pow_mod(&self, mut exp: usize) -> Self {",
      "        let mut res = 1;",
      "        let mut base = self.get() as usize;",
      "        let m = self.get_mod();",
      "        while exp > 0 {",
      "            if exp & 1 != 0 {",
      "                res *= base;",
      "                res %= m;",
      "            }",
      "            base *= base;",
      "            base %= m;",
      "            exp >>= 1;",
      "        }",
      "        Self::new(res, self.get_mod())",
      "    }",
      "    /// `a / b == a * b^(-1)` となる `b^(-1)` を求める",
      "    pub fn inv(&self) -> i64 {",
      "        let x = self.get().extended_gcd(&(self.get_mod() as i64)).x;",
      "        compensated_rem(x, self.get_mod())",
      "    }",
      "}",
      "impl Add<Self> for ModInt {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self::Output {",
      "        let c = check_mod_eq(&self, &rhs);",
      "        if !c.1 {",
      "            panic!(\"modulo between two instance is different!\")",
      "        }",
      "        let r = self.get() + rhs.num;",
      "        Self {",
      "            num: if r >= self.get_mod() as i64 {",
      "                r - c.0.get() as i64",
      "            } else {",
      "                r",
      "            },",
      "            _modulo: Modulo::Static(c.0),",
      "        }",
      "    }",
      "}",
      "impl AddAssign<Self> for ModInt {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        *self = *self + rhs;",
      "    }",
      "}",
      "impl Sub<Self> for ModInt {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self::Output {",
      "        let c = check_mod_eq(&self, &rhs);",
      "        if !c.1 {",
      "            panic!(\"modulo between two instance is different!\")",
      "        }",
      "        let num = compensated_rem(self.get() - rhs.get(), c.0.get() as usize);",
      "        Self {",
      "            num,",
      "            _modulo: Modulo::Static(c.0),",
      "        }",
      "    }",
      "}",
      "impl SubAssign<Self> for ModInt {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        *self = *self - rhs;",
      "    }",
      "}",
      "impl Mul<Self> for ModInt {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Self) -> Self::Output {",
      "        let c = check_mod_eq(&self, &rhs);",
      "        if !c.1 {",
      "            panic!(\"modulo between two instance is different!\")",
      "        }",
      "        let num = compensated_rem(self.get() * rhs.get(), c.0.get() as usize);",
      "        Self {",
      "            num,",
      "            _modulo: Modulo::Static(c.0),",
      "        }",
      "    }",
      "}",
      "impl MulAssign<Self> for ModInt {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        *self = *self * rhs",
      "    }",
      "}",
      "impl Div<Self> for ModInt {",
      "    type Output = Self;",
      "    fn div(self, rhs: Self) -> Self::Output {",
      "        let c = check_mod_eq(&self, &rhs);",
      "        if !c.1 {",
      "            panic!(\"modulo between two instance is different!\")",
      "        }",
      "        Self {",
      "            num: self.get() * rhs.inv() % c.0.get() as i64,",
      "            _modulo: Modulo::Static(c.0),",
      "        }",
      "    }",
      "}",
      "impl DivAssign<Self> for ModInt {",
      "    fn div_assign(&mut self, rhs: Self) {",
      "        *self = *self / rhs;",
      "    }",
      "}",
      "impl Rem for ModInt {",
      "    type Output = Self;",
      "    fn rem(self, rhs: Self) -> Self::Output {",
      "        let c = check_mod_eq(&self, &rhs);",
      "        if !c.1 {",
      "            panic!(\"modulo between two instance is different!\")",
      "        }",
      "        Self {",
      "            num: self.num % rhs.num,",
      "            _modulo: Modulo::Static(c.0),",
      "        }",
      "    }",
      "}",
      "impl RemAssign for ModInt {",
      "    fn rem_assign(&mut self, rhs: Self) {",
      "        *self = *self % rhs",
      "    }",
      "}",
      "impl Zero for ModInt {",
      "    fn zero() -> Self {",
      "        ModInt {",
      "            num: 0,",
      "            _modulo: Modulo::Dynamic,",
      "        }",
      "    }",
      "    fn is_zero(&self) -> bool {",
      "        self.num == 0",
      "    }",
      "}",
      "impl One for ModInt {",
      "    fn one() -> Self {",
      "        ModInt {",
      "            num: 1,",
      "            _modulo: Modulo::Dynamic,",
      "        }",
      "    }",
      "    fn is_one(&self) -> bool {",
      "        self.num == 1",
      "    }",
      "}",
      "impl Num for ModInt {",
      "    type FromStrRadixErr = ParseIntError;",
      "    fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> {",
      "        let num = str",
      "            .chars()",
      "            .rev()",
      "            .enumerate()",
      "            .map(|(i, b)| radix.pow(i as u32) as i64 * b.to_digit(radix).unwrap() as i64)",
      "            .sum::<i64>();",
      "        Ok(ModInt {",
      "            num,",
      "            _modulo: Modulo::Dynamic,",
      "        })",
      "    }",
      "}",
      "impl Pow<usize> for ModInt {",
      "    type Output = Self;",
      "    fn pow(mut self, mut exp: usize) -> Self::Output {",
      "        if exp == 0 {",
      "            return Self::one();",
      "        }",
      "        while exp & 1 == 0 {",
      "            self = self * self;",
      "            exp >>= 1;",
      "        }",
      "        if exp == 1 {",
      "            return self;",
      "        }",
      "        let mut acc = self;",
      "        while exp > 1 {",
      "            exp >>= 1;",
      "            self = self * self;",
      "            if exp & 1 == 1 {",
      "                acc = acc * self;",
      "            }",
      "        }",
      "        acc",
      "    }",
      "}",
      "macro_rules ! impl_ops_between_mint_and_primitive {(\\$ (\\$ t : ty ) ,* ) => {\\$ (impl Add <\\$ t > for ModInt {type Output = Self ; fn add (self , rhs : \\$ t ) -> Self :: Output {self + Self :: new (rhs as i64 , self . get_mod () ) } } impl AddAssign <\\$ t > for ModInt {fn add_assign (& mut self , rhs : \\$ t ) {* self = * self + rhs ; } } impl Sub <\\$ t > for ModInt {type Output = Self ; fn sub (self , rhs : \\$ t ) -> Self :: Output {self - Self :: new (rhs as i64 , self . get_mod () ) } } impl SubAssign <\\$ t > for ModInt {fn sub_assign (& mut self , rhs : \\$ t ) {* self = * self - rhs ; } } impl Mul <\\$ t > for ModInt {type Output = Self ; fn mul (self , rhs : \\$ t ) -> Self :: Output {self * Self :: new (rhs as i64 , self . get_mod () ) } } impl MulAssign <\\$ t > for ModInt {fn mul_assign (& mut self , rhs : \\$ t ) {* self = * self * rhs ; } } impl Div <\\$ t > for ModInt {type Output = Self ; fn div (self , rhs : \\$ t ) -> Self :: Output {self / Self :: new (rhs as i64 , self . get_mod () ) } } impl DivAssign <\\$ t > for ModInt {fn div_assign (& mut self , rhs : \\$ t ) {* self = * self / rhs ; } } ) * } ; }",
      "impl_ops_between_mint_and_primitive!(usize, u8, u16, u32, u64, isize, i8, i16, i32, i64);"
    ]
  },
  "monoid": {
    "prefix": "monoid",
    "body": [
      "/// 単位元が定義される `T -> T -> T`型の演算",
      "pub trait Monoid: Sized {",
      "    fn identity() -> Self;",
      "    fn op(x: &Self, y: &Self) -> Self;",
      "    fn fold(v: &[Self]) -> Self {",
      "        v.iter().fold(Self::identity(), |a, b| Self::op(&a, b))",
      "    }",
      "}",
      "/// Monoidトレイトの自動実装マクロ",
      "///",
      "/// 一行目にモノイド名、",
      "/// 二行目に単位元",
      "/// 三行目に`2引数を取って、同型の演算結果を返すクロージャを渡す",
      "///",
      "/// ```example",
      "/// monoid_def! {",
      "///     Max<usize>,",
      "///     std::usize::MIN,",
      "///     |x: usize, y: usize| x.max(y)",
      "/// }",
      "/// ```",
      "///",
      "#[macro_export]",
      "macro_rules ! monoid_def {{\\$ M : ident <\\$ t : ty >, \\$ id : expr , \\$ me : expr } => {# [derive (Debug , Clone , Copy ) ] pub struct \\$ M (\\$ t ) ; impl Monoid for \\$ M {fn identity () -> Self {\\$ M (\\$ id ) } fn op (x : & Self , y : & Self ) -> Self {let f = \\$ me ; \\$ M (f (x . 0 , y . 0 ) ) } } impl Into <\\$ M > for \\$ t {fn into (self ) -> \\$ M {\\$ M (self ) } } } ; }"
    ]
  },
  "permutation": {
    "prefix": "permutation",
    "body": [
      "/// `n P k` を `O(k)` で",
      "///",
      "/// 内部はfallingをラップしているだけ",
      "pub fn permutation<T: Factoriable>(n: T, k: usize) -> T {",
      "    n.falling(k)",
      "}",
      "pub fn permutation_with_table(table: &BCTDP, n: usize, k: usize) -> ModInt {",
      "    if k > n {",
      "        ModInt::new(0, table.get_mod())",
      "    } else {",
      "        table.factorial(n) * table.factorial_inverse(n - k)",
      "    }",
      "}"
    ]
  },
  "run_length_encoding": {
    "prefix": "run_length_encoding",
    "body": [
      "/// ランレングス圧縮",
      "pub fn run_length_encoding<T: PartialEq + Copy>(v: &Vec<T>) -> Vec<(T, usize)> {",
      "    let mut res = Vec::new();",
      "    let mut c = 1usize;",
      "    let mut h = v[0];",
      "    for e in v.iter().skip(1) {",
      "        if h != *e {",
      "            res.push((h, c));",
      "            c = 1;",
      "            h = *e;",
      "        } else {",
      "            c += 1;",
      "        }",
      "    }",
      "    res.push((h, c));",
      "    res",
      "}"
    ]
  },
  "segment_tree": {
    "prefix": "segment_tree",
    "body": [
      "#[derive(Debug, Clone)]",
      "pub struct SegmentTree<T: Monoid> {",
      "    len: usize,",
      "    size: usize,",
      "    segment: Vec<T>,",
      "}",
      "fn childrens_idx(n: usize) -> (usize, usize) {",
      "    (n * 2 + 1, n * 2 + 2)",
      "}",
      "fn parent_idx(n: usize) -> usize {",
      "    (n - 1) / 2",
      "}",
      "impl<T: Monoid + Clone + Copy> SegmentTree<T> {",
      "    pub fn new<I: Into<T> + Copy>(v: &[I]) -> Self {",
      "        let n = v.len();",
      "        let leaves = n.next_power_of_two();",
      "        let size = 2 * leaves - 1;",
      "        let mut value = vec![T::identity(); size];",
      "        for i in (0..size).rev() {",
      "            if i >= leaves - 1 {",
      "                if i + 1 - leaves < n {",
      "                    value[i] = (v[i + 1 - leaves]).into();",
      "                } else {",
      "                    continue;",
      "                }",
      "            } else {",
      "                let (left, right) = childrens_idx(i);",
      "                value[i] = T::op(&value[left], &value[right]);",
      "            }",
      "        }",
      "        Self {",
      "            len: leaves,",
      "            size,",
      "            segment: value,",
      "        }",
      "    }",
      "    pub fn len(&self) -> usize {",
      "        self.len",
      "    }",
      "    fn childrens(&self, n: usize) -> (T, T) {",
      "        let (left, right) = childrens_idx(n);",
      "        (self.segment[left], self.segment[right])",
      "    }",
      "    /// `i`番目の葉の参照をとる",
      "    pub fn get(&self, i: usize) -> Option<&T> {",
      "        self.segment.get(self.size - self.len + i)",
      "    }",
      "    /// `i`番目の葉の可変参照をとる",
      "    ///",
      "    /// # Unsafe",
      "    ///",
      "    /// 葉の部分は変更されうるけれど、その親要素へ変更が伝達されない",
      "    ///",
      "    /// update()を使うこと",
      "    pub unsafe fn get_mut(&mut self, i: usize) -> Option<&mut T> {",
      "        self.segment.get_mut(self.size - i - 1)",
      "    }",
      "    /// `i`番目の葉を`v`で更新",
      "    pub fn update(&mut self, i: usize, v: T) {",
      "        let mut cur = self.len - self.len + i;",
      "        self.segment[cur] = v;",
      "        loop {",
      "            if cur == 0 {",
      "                break;",
      "            }",
      "            cur = parent_idx(cur);",
      "            let (left, right) = self.childrens(cur);",
      "            self.segment[cur] = T::op(&left, &right);",
      "        }",
      "    }",
      "    /// 区間、`[from..to)`を指定の`Monoid`でfoldした演算結果",
      "    pub fn range(&self, from: usize, to: usize) -> T {",
      "        self.range_inner(from, to, 0, self.len, 0)",
      "    }",
      "    fn range_inner(&self, from: usize, to: usize, l_bound: usize, r_bound: usize, k: usize) -> T {",
      "        if from <= l_bound && to >= r_bound {",
      "            self.segment[k]",
      "        } else if from >= r_bound || to <= l_bound {",
      "            T::identity()",
      "        } else {",
      "            let sep = (l_bound + r_bound) / 2;",
      "            T::op(",
      "                &self.range_inner(from, to, l_bound, sep, 2 * k + 1),",
      "                &self.range_inner(from, to, sep, r_bound, 2 * k + 2),",
      "            )",
      "        }",
      "    }",
      "}"
    ]
  },
  "shuffle": {
    "prefix": "shuffle",
    "body": [
      "pub fn shuffle<T>(v: &mut Vec<T>) {",
      "    for i in (1..v.len()).rev() {",
      "        v.swap(thread_rng().gen_range(0, i), i);",
      "    }",
      "}"
    ]
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "/// 初期化の際にだけエラストテネスの篩を使って素数のリストを生成",
      "///",
      "/// `O(n)`",
      "pub struct Sieve {",
      "    size: usize,",
      "    /// `(0..=n)`までの範囲で",
      "    /// `is_prime[i]` => `i`は素数",
      "    is_prime: Vec<bool>,",
      "    /// `(0..=n)`の全ての素数",
      "    primes: Vec<usize>,",
      "}",
      "impl Sieve {",
      "    /// 初期化、サイズが重要",
      "    pub fn new(n: usize) -> Self {",
      "        let mut spf = vec![None; n + 1];",
      "        let mut is_prime = vec![true; n + 1];",
      "        let mut primes = Vec::new();",
      "        is_prime[0] = false;",
      "        is_prime[1] = false;",
      "        for i in 2..n + 1 {",
      "            if is_prime[i] {",
      "                primes.push(i);",
      "                spf[i] = Some(i);",
      "            }",
      "            for prime in &primes {",
      "                if i * prime >= n + 1 || prime > &spf[i].unwrap() {",
      "                    break;",
      "                }",
      "                is_prime[i * prime] = false;",
      "                spf[i * prime] = Some(*prime);",
      "            }",
      "        }",
      "        Self {",
      "            size: n,",
      "            is_prime,",
      "            primes,",
      "        }",
      "    }",
      "    /// 自分自身の素数リストの有効な範囲",
      "    pub fn size(&self) -> usize {",
      "        self.size",
      "    }",
      "    /// `n`以下の全ての素数のリストを作る",
      "    pub fn primes(&self, n: usize) -> Vec<usize> {",
      "        assert!(self.size() >= n);",
      "        self.primes",
      "            .iter()",
      "            .take_while(|x| **x <= n)",
      "            .cloned()",
      "            .collect()",
      "    }",
      "    /// `n`が素数かどうか",
      "    ///",
      "    /// # Panic",
      "    /// `n > self.size`でindexing panicする",
      "    pub fn is_prime(&self, n: usize) -> bool {",
      "        self.is_prime[n]",
      "    }",
      "}",
      "/// Seiveテーブルを用いた素因数分解",
      "///",
      "/// `n`を素因数分解するためには最小で、",
      "/// `√n`までのサイズの素数テーブルが必要",
      "///",
      "/// # Panic",
      "/// `sieve`のサイズが`√n`未満で不十分な場合にpanicします",
      "pub fn factorizations_with_sieve(sieve: &Sieve, mut n: usize) -> Vec<(usize, usize)> {",
      "    assert!(sieve.size.pow(2) >= n);",
      "    let mut res = Vec::new();",
      "    let ps = sieve.primes((n as f64).sqrt().ceil() as usize);",
      "    for p in ps {",
      "        let mut c = 0usize;",
      "        while n % p == 0 {",
      "            n /= p;",
      "            c += 1;",
      "        }",
      "        if c != 0 {",
      "            res.push((p, c));",
      "        }",
      "    }",
      "    if n > 1 {",
      "        res.push((n, 1));",
      "    }",
      "    res",
      "}"
    ]
  },
  "snippet": {
    "prefix": "snippet",
    "body": [
      "impl UnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            parent: (0..n).collect::<Vec<usize>>(),",
      "            size: vec![1; n],",
      "        }",
      "    }",
      "    pub fn len(&self) -> usize {",
      "        self.parent.len()",
      "    }",
      "    /// i が属する集合の親のインデックス",
      "    pub fn find(&mut self, mut i: usize) -> usize {",
      "        while self.parent[i] != i {",
      "            self.parent[i] = self.find(self.parent[i]);",
      "            i = self.parent[self.parent[i]];",
      "        }",
      "        i",
      "    }",
      "    /// a と b を繋ぐ",
      "    pub fn unite(&mut self, a: usize, b: usize) -> bool {",
      "        let mut a = self.find(a);",
      "        let mut b = self.find(b);",
      "        if a == b {",
      "            return false;",
      "        }",
      "        if self.size[a] < self.size[b] {",
      "            std::mem::swap(&mut a, &mut b);",
      "        }",
      "        self.size[a] += self.size[b];",
      "        self.parent[b] = a;",
      "        true",
      "    }",
      "    /// i が属する集合の要素数",
      "    pub fn count(&mut self, i: usize) -> usize {",
      "        let p = self.find(i);",
      "        self.size[p]",
      "    }",
      "    /// a と b が同一集合に属するか",
      "    pub fn joint(&mut self, a: usize, b: usize) -> bool {",
      "        self.find(a) == self.find(b)",
      "    }",
      "    /// i が属する集合の要素を列挙する",
      "    pub fn get_group(&mut self, i: usize) -> HashSet<usize> {",
      "        let p = self.find(i);",
      "        (0..self.len()).filter(|x| self.find(*x) == p).collect()",
      "    }",
      "}"
    ]
  },
  "trial_division": {
    "prefix": "trial_division",
    "body": [
      "/// 2以上で`x`の約数であるものの内最小であるものを求める",
      "fn firstfac(x: usize) -> usize {",
      "    if x % 2 == 0 {",
      "        return 2;",
      "    };",
      "    for n in (3..).step_by(2).take_while(|m| m * m <= x) {",
      "        if x % n == 0 {",
      "            return n;",
      "        };",
      "    }",
      "    x",
      "}",
      "/// 試し割りによる素数判定です",
      "///",
      "/// `O(√n)`",
      "pub fn is_prime(n: usize) -> bool {",
      "    if n <= 1 {",
      "        return false;",
      "    }",
      "    firstfac(n) == n",
      "}",
      "fn exp(n: &mut usize, d: usize) -> (usize, usize) {",
      "    let mut c = 0usize;",
      "    (",
      "        d,",
      "        loop {",
      "            if *n % d != 0 {",
      "                break c;",
      "            }",
      "            *n /= d;",
      "            c += 1;",
      "        },",
      "    )",
      "}",
      "pub fn factorization(mut n: usize) -> Vec<(usize, usize)> {",
      "    let mut primes = Vec::new();",
      "    let (d, e) = exp(&mut n, 2);",
      "    if e > 0 {",
      "        primes.push((d, e));",
      "    }",
      "    let m = n;",
      "    for i in (3..).take_while(|x| *x * *x <= m).step_by(2) {",
      "        let (d, e) = exp(&mut n, i);",
      "        if e > 0 {",
      "            primes.push((d, e));",
      "        }",
      "    }",
      "    if n > 1 {",
      "        match primes.iter().enumerate().find(|x| (x.1).0 == n) {",
      "            Some((i, _)) => primes[i].1 += 1,",
      "            None => primes.push((n, 1)),",
      "        }",
      "    }",
      "    primes",
      "}"
    ]
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "#[derive(Debug, Clone)]",
      "pub struct UnionFind {",
      "    parent: Vec<usize>,",
      "    size: Vec<usize>,",
      "}"
    ]
  },
  "unique_count": {
    "prefix": "unique_count",
    "body": [
      "/// 配列に含まれる要素(T: Ord + Copy)別にその個数を数えて",
      "/// `BTreeMap<T, usize>`の形にして返す",
      "pub fn unique_count<T: Ord + Copy>(v: &[T]) -> BTreeMap<T, usize> {",
      "    let mut map = BTreeMap::new();",
      "    for e in v {",
      "        let h = map.entry(*e).or_insert(0);",
      "        *h += 1;",
      "    }",
      "    map",
      "}"
    ]
  },
  "visualize": {
    "prefix": "visualize",
    "body": [
      "pub trait Visualize {",
      "    fn visualize(&self, split: &str);",
      "    fn continuous(&self) {",
      "        self.visualize(\"\");",
      "    }",
      "    fn spaces(&self) {",
      "        self.visualize(\" \");",
      "    }",
      "    fn lines(&self) {",
      "        self.visualize(\"\\n\");",
      "    }",
      "}",
      "macro_rules ! impl_vis_for_sized {(\\$ (\\$ t : ty ) ,+ ) => {\\$ (impl Visualize for \\$ t {fn visualize (& self , _split : & str ) {print ! (\"{}\" , self ) ; } } ) + } ; }",
      "impl_vis_for_sized! {usize , u8 , u16 , u32 , u64 , u128 , isize , i8 , i16 , i32 , i64 , i128 , String , & str }",
      "impl<T: fmt::Display> Visualize for [T] {",
      "    fn visualize(&self, split: &str) {",
      "        print!(\"{}\", self.iter().join(split));",
      "    }",
      "}",
      "/// macro to output answer improved to println",
      "///",
      "/// this macro will print '\\n' at the last.",
      "///",
      "/// # Patterns",
      "///",
      "/// `,`, it means one space, it formats the elements, which is before, space-split.",
      "/// And insert a space after the prefix, unless it is at last.",
      "///",
      "/// `=>`, it means empty string, it formats the element, witch is before, without any split.",
      "/// And insert nothing between two element.",
      "///",
      "/// `;`, it means newline(\\n), it formats the element, witch is before, newline-split.",
      "/// And insert a newline after the prefix, unless it is at last.",
      "///",
      "/// # Eample",
      "///",
      "/// ```",
      "/// #[test]",
      "/// fn vis_test() {",
      "///     let a = 1;",
      "///     let b = 2;",
      "///     let c = 3;",
      "///",
      "///     let v = vec!['a', 'b', 'c'];",
      "///",
      "///     // single element test ...",
      "///",
      "///     vis!(a); // 1\\n",
      "///     vis!(a,); // 1\\n",
      "///     vis!(a =>); // 1\\n",
      "///     vis!(a;); // 1\\n",
      "///",
      "///     println!();",
      "///",
      "///     vis!(a + b); // 3\\n",
      "///",
      "///     println!();",
      "///",
      "///     vis!(v); // a b c\\n",
      "///     vis!(v,); // a b c\\n",
      "///     vis!(v =>); // abc\\n",
      "///     vis!(v;); // a\\nb\\nc\\n",
      "///",
      "///     println!();",
      "///",
      "///     // multi elements connected by common operater test ...",
      "///",
      "///     println!();",
      "///",
      "///     vis!(a, b); // 1 2\\n",
      "///     vis!(a, b, c); // 1 2 3\\n",
      "///     vis!(a, b, c;); // 1 2 3\\n",
      "///",
      "///     println!();",
      "///",
      "///     vis!(a => b); // 12\\n",
      "///     vis!(a => b => c); // 123\\n",
      "///     vis!(a => b => c ,); // 123\\n",
      "///",
      "///     println!();",
      "///",
      "///     vis!(a; b); // 1\\n2\\n",
      "///     vis!(a; b; c); // 1\\n2\\n3\\n",
      "///     vis!(a; b; c =>); // 1\\n2\\n3\\n",
      "///",
      "///     println!();",
      "///",
      "///     // multi elements connected by different operater test ...",
      "///",
      "///     vis!(a, b; c); // 1 2\\n3\\n",
      "///     vis!(a; b, c); // 1\\n2 3\\n",
      "///     vis!(a => b, c); // 12 3\\n",
      "///     vis!(a; b => c); // 1\\n23\\n",
      "///",
      "///     println!();",
      "///",
      "///     vis!(a, v); // 1 a b c\\n;",
      "///     vis!(a, v;); // 1 a\\nb\\nc\\n;",
      "///     vis!(a => v =>); // 1abc\\n;",
      "///",
      "///     println!(\"\\\\d\");",
      "///     // panic!()",
      "/// }",
      "/// ```",
      "#[macro_export]",
      "macro_rules ! vis {() => {println ! () ; } ; (\\$ last : expr ; ) => {\\$ last . lines () ; vis ! () } ; (\\$ last : expr => ) => {\\$ last . continuous () ; vis ! () ; } ; (\\$ last : expr \\$ (, ) ? ) => {\\$ last . spaces () ; vis ! () ; } ; (\\$ first : expr ; \\$ (\\$ rest : tt ) * ) => {\\$ first . lines () ; println ! () ; vis ! (\\$ (\\$ rest ) * ) ; } ; (\\$ first : expr => \\$ (\\$ rest : tt ) * ) => {\\$ first . continuous () ; vis ! (\\$ (\\$ rest ) * ) ; } ; (\\$ first : expr , \\$ (\\$ rest : tt ) * ) => {\\$ first . spaces () ; print ! (\" \" ) ; vis ! (\\$ (\\$ rest ) * ) ; } ; }"
    ]
  }
}
